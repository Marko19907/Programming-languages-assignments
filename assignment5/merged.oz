
% Task 1 a)

% Execute the following code in Mozart and observe the results. What sequence of numbers gets printed
% as output of the Oz environment?

local A=10 B=20 C=30 in
    {System.show C}

    thread
        {System.show A}
        {Delay 100}
        {System.show A * 10}
    end
    
    thread
        {System.show B}
        {Delay 100}
        {System.show B * 10}
    end

    {System.show C * 100}
end


% Possible output:
% 30
% 3000
% 10
% 20
% 200
% 100



% Task 1 c)

% Execute the following code in Mozart and observe the results. What sequence of numbers gets printed
% as output of the Oz environment?

local A B C in
    thread
        A = 2
        {System.show A}
    end

    thread
        B = A * 10
        {System.show B}
    end

    C = A + B
    {System.show C}
end


% Possible output:
% 2
% 20
% 22



% Task 2 a)

% Implement a function fun {Enumerate Start End} that generates, asynchronously, a stream of numbers
% from Start until End.
% {System.show {Enumerate 1 5}} should print [1 2 3 4 5]
% Hint: You can use the thread ... end statement inside the definition of the function, to wrap the iterative
% process that generates the numbers.

declare fun {EnumerateHelper N Limit}
    if N > Limit then nil
    else
        N | {EnumerateHelper N + 1 Limit}
    end
end

declare fun {Enumerate Start End}
    thread
        {EnumerateHelper Start End}
    end
end


{Browse {Enumerate 1 5}}      % [1 2 3 4 5]
{System.show {Enumerate 1 5}} % prints _<optimized> because it is a stream and it is not evaluated until it is needed; not sure how to force it to evaluate as the task asks



% Task 2 b)

% Implement a function fun {GenerateOdd Start End} that generates, asynchronously, a stream of odd
% numbers from Start to End. The GenerateOdd function must be implemented as a consumer of Enumerate.
% That is, it must read the stream generated by Enumerate and filter it as appropriate.
% {System.show {GenerateOdd 1 5}} should print [1 3 5]
% {System.show {GenerateOdd 4 4}} should print nil

declare fun {GenerateOdd Start End}
    local Input Result in
        thread Input = {Enumerate Start End} end
        thread Result = case Input of H|T then
            if {Int.isOdd H} then
                H | {GenerateOdd Start + 1 End}
            else
                {GenerateOdd Start + 1 End}
            end
            else nil end
        end
        Result
    end
end


{System.show {GenerateOdd 1 5}} % _<optimized>, same as above
{Browse {GenerateOdd 1 5}}      % [1 3 5]

{System.show {GenerateOdd 4 4}} % _<optimized>
{Browse {GenerateOdd 4 4}}      % nil



% Task 3 a)

% Implement the function fun {ListDivisorsOf Number}, which produces a stream of all the divisors of
% the integer number Number. A number d ∈ N is a divisor of n ∈ N if the rest of the integer division n/d is zero.
% The modulo operation (i.e., rest of integer division) is denoted with the keyword mod in Oz. ListDivisorOf
% must be implemented as a consumer of Enumerate.

declare fun {ListDivisorsOf Number}
    local
        Input Result FilterDivisors
    in
        thread Input = {Enumerate 1 Number} end
        fun {FilterDivisors List}
            case List of H|T then
                if Number mod H == 0 then
                    H | {FilterDivisors T}
                else
                    {FilterDivisors T}
                end
            else nil end
        end
        thread Result = {FilterDivisors Input} end
        Result
    end
end


{Browse {ListDivisorsOf 20}} % [1 2 4 5 10 20]



% Task 3 b)

% Implement the function fun {ListPrimesUntil N}, which produces a stream of all the prime numbers
% up to the number N. A number n is prime if its only divisors are 1 and n itself. ListDivisorOf must be
% implemented as a consumer of Enumerate.
% Hint: You can chain multiple streams, and also consume multiple streams in the implementation of a function.
% In particular, you should also consume the stream produced by ListDivisorsOf.

declare fun {ListPrimesUntil N}
    local
        Input Result FilterPrimes
    in
        thread Input = {Enumerate 1 N} end
        fun {FilterPrimes List}
            case List of H|T then
                if {ListDivisorsOf H} == [1 H] then % if the list of divisors is 1 and the number H itself, [1 H], then H is prime
                    H | {FilterPrimes T}
                else
                    {FilterPrimes T}
                end
            else nil end
        end
        thread Result = {FilterPrimes Input} end
        Result
    end
end


{Browse {ListPrimesUntil 20}} % [2 3 5 7 11 13 17 19]



% Task 4 a)

% Implement a function fun {Enumerate} as a lazy function that generates an infinite stream of numbers,
% starting from 1.

declare fun lazy {EnumerateHelper N}
    N | {EnumerateHelper N + 1}
end

declare fun lazy {Enumerate}
    {EnumerateHelper 1}
end


{Browse {List.take {Enumerate} 10}}  % [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]



% Task 4 b)

% Implement a function fun {Primes} as a lazy function that generates an infinite stream of prime
% numbers, starting from 2. You must implement Primes as a consumer of the stream produced by Enumerate,
% and any other streams you find useful.

declare fun lazy {Divisors N S}
    case S of H|T then
        if H mod N == 0 then
            {Filter N T}
        else
            H | {Filter N T}
        end
    else
        nil
    end
end

fun lazy {PrimesHelper S}
    case S of H|T then
        H | {PrimesHelper {Divisors H T}}
    else
        nil
    end
end

declare fun lazy {Primes}
    case {Enumerate} of H|T then
        {PrimesHelper T} % Call PrimesHelper with the tail of the stream to skip the first element so that we can start at 2
                         % An alternative would be to use {PrimesHelper {EnumerateHelper 2}} but the goal was to use Enumerate
    end
end


{Browse {List.take {Primes} 10}}  % [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
