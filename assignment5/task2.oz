
% Task 2 a)

% Implement a function fun {Enumerate Start End} that generates, asynchronously, a stream of numbers
% from Start until End.
% {System.show {Enumerate 1 5}} should print [1 2 3 4 5]
% Hint: You can use the thread ... end statement inside the definition of the function, to wrap the iterative
% process that generates the numbers.

declare fun {EnumerateHelper N Limit}
    if N > Limit then nil
    else
        N | {EnumerateHelper N + 1 Limit}
    end
end

declare fun {Enumerate Start End}
    thread
        {EnumerateHelper Start End}
    end
end


{Browse {Enumerate 1 5}}      % [1 2 3 4 5]
{System.show {Enumerate 1 5}} % prints _<optimized> because it is a stream and it is not evaluated until it is needed; not sure how to force it to evaluate as the task asks



% Task 2 b)

% Implement a function fun {GenerateOdd Start End} that generates, asynchronously, a stream of odd
% numbers from Start to End. The GenerateOdd function must be implemented as a consumer of Enumerate.
% That is, it must read the stream generated by Enumerate and filter it as appropriate.
% {System.show {GenerateOdd 1 5}} should print [1 3 5]
% {System.show {GenerateOdd 4 4}} should print nil

declare fun {GenerateOdd Start End}
    local Input Result in
        thread Input = {Enumerate Start End} end
        thread Result = case Input of H|T then
            if {Int.isOdd H} then
                H | {GenerateOdd Start + 1 End}
            else
                {GenerateOdd Start + 1 End}
            end
            else nil end
        end
        Result
    end
end


{System.show {GenerateOdd 1 5}} % _<optimized>, same as above
{Browse {GenerateOdd 1 5}}      % [1 3 5]

{System.show {GenerateOdd 4 4}} % _<optimized>
{Browse {GenerateOdd 4 4}}      % nil
